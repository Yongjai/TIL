## Multi-thread Perform Seletor

이번 주제가 멀티 스레드에 대한 얘기이므로 왜 멀티 스레드를 써야하는지에 대해 먼저 얘기를 해야 할 것 같다.

하나의 앱은 하나의 프로세스로 이루어져 있고 그 프로세스 안에는 최소 한 개의 스레드가 동작하고 있다. 앱이 실행시키면 메인 스레드가 가장 먼저 동작한다.  메인 스레드는 이벤트 루프를 돌면서 이벤트가 있을 때마다 함수를 호출한다. 일반적으로 앱은 메인스레드를 중심으로 실행이 되기 때문에 이 메인 스레드를 멈추게 하는 일이 있으면 안된다. 그렇기 때문에 사용자의 모든 인터렉션은 메인 스레드에서 실행이 되도록 해야한다. 

만약 서버에서 데이터를 받아올 때, 메인 스레드를 사용하게 앱이 멈출 수 있다. 이유는 간단하다. 메인 스레드를 사용하게 되면 메인 스레드에서 발생하는 작업이 끝나기 전까지 다음 작업으로 넘어가지 않기 때문에 서버에서 데이터를 받아오는데 시간이 걸리게 되면 걸리는 시간만큼 앱이 멈출 수 밖에 없다. 이러한 문제를 해결하기 다른 스레드를 사용해서 서버에서 데이터를 받아오게 해야한다. 즉, 메인 스레드에서는 사용자의 인터렉션과 관련된 화면 처리나 기본적인 작동을 처리하게 하고, 시간이 오래 걸리는 작업은 다른 스레드를 이용해서 작업해야한다. 이것이 멀티 스레드이다. 

멀티 스레드를 사용하려면 우선 메인 스레드가 아닌 새로운 스레드 객체를 선언해주어야 한다. 

```objective-c
NSThread *testThread;
testThread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil];
[testThread start];
```

위와 같은 코드로 스레드를 만들고 실행시킬 수 있다. 그러면 만약 어떤 스레드에서 다른 스레드의 함수를 호출하려면 어떻게 해야 할까? 그 때 필요한 것이 `-performSelector:` 메소드이다.

-performSelector: 메소드는 NSObject 클래스에 구현이 되어 있으며 이 메소드는 Thread 선택과 지연 메시지 전달이 가능하다. 

지연 메시지가 어떤 방식으로 전달이 되는지 자세히 알아보자.

Run Loop… 한국말로 실행 루프라고 불리는 녀석이 있다. NSRunLoop 클래스에 속하면서 운영체제가 자고 있는 스레드를 깨우고 이벤트가 들어오면 이 이벤트를 관리하는 게 바로 실행 루프이다. 실행 루프는 작업을 예약하고 일정 시간 동안 들어온 이벤트를 처리한다. iOS에서 각각의 스레드들은 실행 루프를 최대 한 개 가질 수 있으며 메인 스레드에 대한 실행 루프는 자동으로 실행된다. 

 iOS 앱을 실행하면 무조건 하나 이상의 스레드가 동작하는데 무조건에 해당하는 것이 메인 스레드이다. 사용자의 모든 인터렉션은 메인 스레드에서 실행이된다. 프로그램의 동작에 따라 스레드를 추가할 수 있는데 실행 루프는 자신의 이벤트 큐에 있는 이벤트를 불러와 처리하는 작업을 계속 반복한다. 만약 큐에 이벤트가 없어지면 해당 스레드는 일시적으로 멈추게 된다. 

이제 performSelector:에 해당하는 다양한 메소드에 대해 알아보자.

####  - performSelecotor :withObject: afterDelay:

`````
해당 메소드는 메소드를 통한 지연 메시지 전달은 메소드 호출 이벤트를 현재 실행 중인 실행 루프의 이벤트 큐에 쌓음으로써 구현된다. 지연 시간에 대한 afterDelay:는 메시지 전송 시점을 보장하는 것이 아니라 일정 시간 내에 메시지가 전송되지 않음을 보장한다.
`````

#### - performSelectorOnMainThread:

````
메인 스레드가 아닌 다른 작업 스레드에서 -performSelectorOnMainThread:를 이용하면 메인 스레드의 이벤트 큐에 메소드 호출 이벤트를 쌓을 수 있다. 타이머와 연동되는 사용자 인터페이스 관련 이벤트 등을 처리할 때 유용하다.
-performSelector:onThread: 메소드를 이용하면 특정 스레드의 이벤트 큐에 메소드 호출 이벤트를 쌓을 수 있다.
````

#### - performSelector:onThread: & -performSelectorOnMainThread:

````
-performSelector:onThread: 메소드와 -performSelectorOnMainThread: 메소드의 경우, 작업을 실행할 스레드와
-performSelector: 메소드를 호출하는 현재 스레드가 동일하다면 메시지를 이벤트 큐에 쌓지 않고 수신자에게 즉시 전송한다.
````

#### - performSelector: 

````
-performSelector: 메소드의 여러 인자 중 wait 인자를 이용하면 동기/비동기 구현도 가능한다. wait 인자를 NO 지정하면 비동기 전송, YES 지정하면 동기 전송이 된다. 또한  mode 인자를 통해 실행 루프의 모드를 설정할 수 있다. 실행 루프는 각자 특정 모드로 실행되는데, 모드는 일부 이벤트를 필터링해 무시하고 처리하지 않는 용도로 사용된다.
````

#### - performSelectorInBackground: 

````
-performSelectorInBackground: 메소드는 작업용 스레드를 새로 생성한 후 생성된 스레드에서 지정된 메시지를 처리하게 한다. 이 메소드는 지정된 메시지 하나를 처리하는 목적으로 스레드를 생성하므로 이벤트 큐와 실행 루프를 사용하지 않는다. 메시지를 처리하고 나면 새로 생긴 스레드는 제거된다.
````

이렇게 -performSelector : 메소드에 대해 알아보았는데 이 메소드들의 단점은 전달 가능한 인자 개수에 제한이 있다는 점과 전달 인자 타입이 객체 포인터(id)로 지정되어 있어 정수형 포인터 같은 경우 (id)&tempInteger 와 같이 타입 캐스팅이 필요하다는 점이다. (인자가 없으면 nil 을 넘겨주면 된다.)



**출처** : 
	* https://soulpark.wordpress.com/2012/08/28/objective_c_sending_messages/

	*http://linkedlist.tistory.com/category/%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%8F%B0/iPhone




